---
title: Subscribe to Events
description: Listen for events and react to them in real-time.
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { DynamicCodeBlock } from 'fumadocs-ui/components/dynamic-codeblock';
import { Callout } from 'fumadocs-ui/components/callout';

## Subscribe to events

Use the `subscribe` method to listen for specific event types and react to them in real-time.

### Basic Usage

<Tabs items={['Kotlin', 'Java']}>
  <Tab value="Kotlin">
    <DynamicCodeBlock
      lang="kotlin"
      code={`// Subscribe to player join events
eventProvider.subscribe(PlayerJoinEvent::class.java) { event ->
    println("Player joined: \${event.player.name}")
    // Handle player join logic
}

// Subscribe to service state changes
eventProvider.subscribe(ServiceChangeStateEvent::class.java) { event ->
    println("Service state changed: \${event.service.name()}")
    // Handle service state change logic
}`}
    />
  </Tab>
  <Tab value="Java">
    <DynamicCodeBlock
      lang="java"
      code={`// Subscribe to player join events
eventProvider.subscribe(PlayerJoinEvent.class, event -> {
    System.out.println("Player joined: " + event.getPlayer().getName());
    // Handle player join logic
});

// Subscribe to service state changes
eventProvider.subscribe(ServiceChangeStateEvent.class, event -> {
    System.out.println("Service state changed: " + event.getService().name());
    // Handle service state change logic
});`}
    />
  </Tab>
</Tabs>

<Callout type="info">
  Event subscriptions are persistent and will continue to receive events until the application is stopped or the subscription is cancelled.
</Callout>

## Built-in Event Subscriptions

Subscribe to common system events:

<Tabs items={['Kotlin', 'Java']}>
  <Tab value="Kotlin">
    <DynamicCodeBlock
      lang="kotlin"
      code={`// Player events
eventProvider.subscribe(PlayerJoinEvent::class.java) { event ->
    val player = event.player
    println("Player \${player.name} joined \${player.currentServiceName}")
    // Update player count, send welcome message, etc.
}

eventProvider.subscribe(PlayerLeaveEvent::class.java) { event ->
    val player = event.player
    println("Player \${player.name} left \${player.currentServiceName}")
    // Update player count, cleanup, etc.
}

// Service events
eventProvider.subscribe(ServiceChangeStateEvent::class.java) { event ->
    val service = event.service
    when (service.state) {
        ServiceState.RUNNING -> println("Service \${service.name()} is running")
        ServiceState.STOPPED -> println("Service \${service.name()} stopped")
        ServiceState.STARTING -> println("Service \${service.name()} starting")
    }
}

eventProvider.subscribe(ServiceChangePlayerCountEvent::class.java) { event ->
    val service = event.service
    println("Player count changed for \${service.name()}: \${service.playerCount}")
}

// Log events
eventProvider.subscribe(ServiceLogEvent::class.java) { event ->
    println("Service \${event.service.name()} log: \${event.line}")
}`}
    />
  </Tab>
  <Tab value="Java">
    <DynamicCodeBlock
      lang="java"
      code={`// Player events
eventProvider.subscribe(PlayerJoinEvent.class, event -> {
    PolocloudPlayer player = event.getPlayer();
    System.out.println("Player " + player.getName() + " joined " + player.getCurrentServiceName());
    // Update player count, send welcome message, etc.
});

eventProvider.subscribe(PlayerLeaveEvent.class, event -> {
    PolocloudPlayer player = event.getPlayer();
    System.out.println("Player " + player.getName() + " left " + player.getCurrentServiceName());
    // Update player count, cleanup, etc.
});

// Service events
eventProvider.subscribe(ServiceChangeStateEvent.class, event -> {
    Service service = event.getService();
    switch (service.getState()) {
        case RUNNING:
            System.out.println("Service " + service.name() + " is running");
            break;
        case STOPPED:
            System.out.println("Service " + service.name() + " stopped");
            break;
        case STARTING:
            System.out.println("Service " + service.name() + " starting");
            break;
    }
});

eventProvider.subscribe(ServiceChangePlayerCountEvent.class, event -> {
    Service service = event.getService();
    System.out.println("Player count changed for " + service.name() + ": " + service.getPlayerCount());
});

// Log events
eventProvider.subscribe(ServiceLogEvent.class, event -> {
    System.out.println("Service " + event.getService().name() + " log: " + event.getLine());
});`}
    />
  </Tab>
</Tabs>

## Custom Event Subscriptions

Subscribe to your own custom events:

<Tabs items={['Kotlin', 'Java']}>
  <Tab value="Kotlin">
    <DynamicCodeBlock
      lang="kotlin"
      code={`// Subscribe to custom events
eventProvider.subscribe(MyCustomEvent::class.java) { event ->
    println("Received custom event: \${event.message}")
    // Handle custom event logic
}

eventProvider.subscribe(ServiceMetricsEvent::class.java) { event ->
    println("Service \${event.serviceName} metrics: CPU \${event.cpuUsage}%, Memory \${event.memoryUsage}%")
    // Process metrics, update dashboard, etc.
}`}
    />
  </Tab>
  <Tab value="Java">
    <DynamicCodeBlock
      lang="java"
      code={`// Subscribe to custom events
eventProvider.subscribe(MyCustomEvent.class, event -> {
    System.out.println("Received custom event: " + event.getMessage());
    // Handle custom event logic
});

eventProvider.subscribe(ServiceMetricsEvent.class, event -> {
    System.out.println("Service " + event.getServiceName() + " metrics: CPU " + 
                      event.getCpuUsage() + "%, Memory " + event.getMemoryUsage() + "%");
    // Process metrics, update dashboard, etc.
});`}
    />
  </Tab>
</Tabs>

## Event Handler Examples

### Service Monitoring

<Tabs items={['Kotlin', 'Java']}>
  <Tab value="Kotlin">
    <DynamicCodeBlock
      lang="kotlin"
      code={`// Monitor all service state changes
eventProvider.subscribe(ServiceChangeStateEvent::class.java) { event ->
    val service = event.service
    val timestamp = System.currentTimeMillis()
    
    when (service.state) {
        ServiceState.RUNNING -> {
            println("[\$timestamp] Service \${service.name()} is now running")
            // Start health checks, update status dashboard
        }
        ServiceState.STOPPED -> {
            println("[\$timestamp] Service \${service.name()} has stopped")
            // Cleanup resources, notify administrators
        }
        ServiceState.STARTING -> {
            println("[\$timestamp] Service \${service.name()} is starting")
            // Wait for startup, prepare monitoring
        }
    }
}`}
    />
  </Tab>
  <Tab value="Java">
    <DynamicCodeBlock
      lang="java"
      code={`// Monitor all service state changes
eventProvider.subscribe(ServiceChangeStateEvent.class, event -> {
    Service service = event.getService();
    long timestamp = System.currentTimeMillis();
    
    switch (service.getState()) {
        case RUNNING:
            System.out.println("[" + timestamp + "] Service " + service.name() + " is now running");
            // Start health checks, update status dashboard
            break;
        case STOPPED:
            System.out.println("[" + timestamp + "] Service " + service.name() + " has stopped");
            // Cleanup resources, notify administrators
            break;
        case STARTING:
            System.out.println("[" + timestamp + "] Service " + service.name() + " is starting");
            // Wait for startup, prepare monitoring
            break;
    }
});`}
    />
  </Tab>
</Tabs>

<Callout type="tip">
  Event subscriptions enable real-time monitoring and reactive programming patterns. Use them to build responsive, event-driven applications.
</Callout>

## Return value

- **Type:** <code>void</code>
- **Behavior:** Asynchronous - events are delivered to the callback as they occur

The subscription remains active until the application is stopped or the connection is lost.
